# 数据基本操作

## 导入库
```python
import torch
```

## 张量的基本操作

### 创建张量
```python
x = torch.arange(12)
x
```
输出：
```
tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
```

### 查看张量形状和元素个数
```python
x.shape, x.numel()
```
输出：
```
(torch.Size([12]), 12)
```

### 改变张量形状
```python
x = x.reshape(3, 4)
x
```
输出：
```
tensor([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
```

### 创建特定张量
```python
torch.zeros((2, 3, 4)), torch.ones((2, 3, 4))
```
输出：
```
(tensor([[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]],
 
         [[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]), tensor([[[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]],
 
         [[1., 1., 1., 1.],
          [1., 1., 1., 1.],
          [1., 1., 1., 1.]]]))
```

### 使用列表创建张量
```python
torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
```
输出：
```
tensor([[2, 1, 4, 3],
        [1, 2, 3, 4],
        [4, 3, 2, 1]])
```

## 张量的运算

### 基本算术运算
```python
x = torch.tensor([1.0, 2, 4, 8])
y = torch.tensor([2, 2, 2, 2])
x + y, x - y, x * y, x / y, x ** y
```
输出：
```
(tensor([ 3.,  4.,  6., 10.]), tensor([-1.,  0.,  2.,  6.]), tensor([ 2.,  4.,  8., 16.]), tensor([0.5000, 1.0000, 2.0000, 4.0000]), tensor([ 1.,  4., 16., 64.]))
```

### 指数运算
```python
torch.exp(x)
```
输出：
```
tensor([2.7183, 7.3891, 54.5982, 2980.9570])
```

### 张量连接
```python
x = torch.arange(12, dtype=torch.float32).reshape(3, 4)
y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((x, y), dim=0), torch.cat((x, y), dim=1)
```
输出：
```
(tensor([[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.],
        [ 8.,  9., 10., 11.],
        [ 2.,  1.,  4.,  3.],
        [ 1.,  2.,  3.,  4.],
        [ 4.,  3.,  2.,  1.]]), tensor([[ 0.,  1.,  2.,  3.,  2.,  1.,  4.,  3.],
        [ 4.,  5.,  6.,  7.,  1.,  2.,  3.,  4.],
        [ 8.,  9., 10., 11.,  4.,  3.,  2.,  1.]]))
```

### 逻辑运算
```python
x == y
```
输出：
```
tensor([[ True, False, False, False],
        [False,  True, False, False],
        [False, False,  True, False]])
```

### 求和
```python
x.sum()
```
输出：
```
tensor(66.)
```

## 广播机制
```python
a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))
a, b, a + b
```
输出：
```
(tensor([[0],
        [1],
        [2]]), tensor([[0, 1]]), tensor([[0, 1],
        [1, 2],
        [2, 3]]))
```

## 张量索引

### 访问数据
```python
x[-1], x[1:3]
```
输出：
```
(tensor([ 8,  9, 10, 11]), tensor([[ 4,  5,  6,  7],
        [ 8,  9, 10, 11]]))
```

### 修改数据
```python
x[1, 2] = 9
x
x[0:2, :] = 12
x
```
输出：
```
tensor([[12, 12, 12, 12],
        [12, 12,  9, 12],
        [ 8,  9, 10, 11]])
tensor([[12, 12, 12, 12],
        [12, 12, 12, 12],
        [ 8,  9, 10, 11]])
```

## 内存操作

### 内存重新分配
```python
before = id(y)
Y = y + x
id(Y) == before
```
输出：
```
False
```

### 原地操作
```python
z = torch.zeros_like(y)
print('id(z):', id(z))
z[:] = y + x
print('id(z):', id(z))
```
输出：
```
id(z): 140686007007856
id(z): 140686007007856
```

### 减少内存开销
```python
before = id(x)
x += y
id(x) == before
```
输出：
```
True
```

## 转换

### 转换为NumPy张量
```python
A = x.numpy()
B = torch.tensor(A)
type(A), type(B)
```
输出：
```
(<class 'numpy.ndarray'>, <class 'torch.Tensor'>)
```

### 转换为Python标量
```python
a = torch.tensor([3.5])
a, a.item(), float(a), int(a)
```
输出：
```
(tensor([3.5000]), 3.5, 3.5, 3)
```

# 思考
torch的大多数方法类似于之前学过的NumPy，换汤不换药，感觉简单
